{% extends "base.html" %}
{% load staticfiles %}

{% block head %}
{{block.super}}
<script src="https://cdn.plot.ly/plotly-latest.js"></script>
{% endblock %}

{% block content %}

<div class="container">
  <h1>Plot using Plot.ly and some clever JavaScript</h1>
  <p class="lead">Here we go...</p>
</div>

<div class="container">
  <div class="row" style="border: 1px solid black">
    <div id="plot_container" class="col-md-12">{{plot|safe}}</div>
  </div>
</div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <br/>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <pre>
        var myDiv = $('.plotly-graph-div')[0];
        myDiv.on('plotly_selected', function(eventData) {
        console.log(eventData.points);
        for (var idx = 0; idx < eventData.points.length; idx++) {
                                console.log(eventData.points[idx]);
                                };
                                });
                                </pre>
    </div>
  </div>
</div>

{% endblock %}

{% block localjs %}
<script type="text/javascript" src="{% static 'app1/Cobyla.js' %}"></script>
<script type="text/javascript">
    
  //
  // Fit the provided data to a nonlinear curve
  //
  
  cobyla = (function(my) {
      "use strict"
      // adds nlFit to cobyla, if it exists
      
      my.nlFit = function nlFit(data, fitFn, start, min, max, constraints, solverParams) {
          // nlFit will minimize the sum of squared differences (y1^2-y2^2) between
          // the data points (x,y1) and the fitFn (x,y2).
          //
          // Returns an object {params: [the best-fit parameters], obj: sum sqr diff, status: status}
          // where status 0 = normal, 1 = max iterations reached, 2 = diverging rounding errors
          //
          // eg.
          //     data = [[0,0.01], [5, 0.1], [100,0.5], [500, 0.9], [1000,0.99]];
          //     cobyla.nlFit(data, weibullCDF, [1, 5, 1], [0,0,0], null, cobyla.constrainAsCDF, {maxFun: 5000});
          //
          // data should be of the form [[x1,y1], [x2,y2], ...]
          // eg. [[0,0.01], [5, 0.1], [100,0.5], [500, 0.9], [1000,0.99]]
          // fitFn should be a function of x and an array of parameters
          //
          // start, min, max are arrays of values for the parameters
          // start is required
          // min, max are ignored if falsy
          //
          // contraints (optional) is a function of the data, fitFn & the parameters
          // which returns an array of inequalities (>0),
          // eg. if params=[a,b,c] then constraints(params) might return
          //     [0,1,1,2,5,10]
          //     each of which will passed into the solver as constraints >0
          //
          // solverParams is an object with any of the keys rhoStart, rhoEnd, iprint, maxFun
          // if any of the keys are missing they default to 5, 1e-6, 0 and 5000 respectively
          
          var x = start;
          var numConstraints = 0;
          if (min) { numConstraints += min.length; }
          if (max) { numConstraints += max.length; }
          if (constraints) { numConstraints += constraints(data, fitFn, x).length; }
          if (!solverParams) { solverParams = {}; }
          
          var defaultSPs = { rhoStart: 5.0, rhoEnd: 1.0e-6, iprint: 0, maxFun: 3500 };
          
          function obj(n, m, x, con) {
              // objective function
              // n is the number of variables to solve for
              // m is the number of constraints
              // x is an array of the variables
              // con is an array of the constraints
              
              var sumSqr = 0;
              var c = 0;
              var i, yData, yFit, cx;
              
              for (i=0; i<data.length; i++) {
                  yData = data[i][1];
                  yFit  = fitFn(data[i][0], x);
                  sumSqr += (yData - yFit) * (yData - yFit);
              }
              if (min) {
                  for (i=0; i<min.length; i++) { con[c++] = x[i] - min[i]; } // x - min > 0, ie. x > min
              }
              if (max) {
                  for (i=0; i<max.length; i++) { con[c++] = max[i] - x[i]; } // max - x > 0, ie. x < max
              }
              if (constraints) {
                  cx = constraints(data, fitFn, x);
                  for (i=0; i<cx.length; i++) { con[c++] = cx[i]; }
              }
              return sumSqr;
          }
          
          var status = cobyla.findMinimum(obj, 
                                          x.length,
                                          numConstraints,
                                          x,
                                          typeof solverParams.rhoStart==="undefined" ? defaultSPs.rhoStart : solverParams.rhoStart,
                                          typeof solverParams.rhoEnd==="undefined" ? defaultSPs.rhoEnd : solverParams.rhoEnd,
                                          typeof solverParams.iprint==="undefined" ? defaultSPs.iprint : solverParams.iprint,
                                          typeof solverParams.maxFun==="undefined" ? defaultSPs.maxFun : solverParams.maxFun );
          
          return {params: x, obj: obj(x.length, numConstraints, x, new Array(numConstraints)), status: status};
      }
      
      //
      // sample constraints function
      //
      
      my.constrainAsCDF = function (data, fitFn, params) {
          // Requires the fit function to be between 0 and 1 at each data point
          var constraints = [],
              yFit;
          for (var i=0; i<data.length; i++) {
              yFit = fitFn(data[i][0], params);
              constraints.push(yFit);  // require yFit > 0
              constraints.push(1-yFit);  // require 1 - yFit > 0, ie. yFit < 1
          }
          return constraints;
      }
      
      return my;
      
  }(typeof cobyla==="undefined" ? {} : cobyla));
</script>
<script type="text/javascript">

  (function() {
      var graphDiv = $("#plot_container .plotly-graph-div")[0],
          trace = null,
          fullData = graphDiv.data[0],
          fullX = fullData.x,
          fullY = fullData.y,
          fullMinY = fullY.reduce((a, b) => Math.min(a, b), Math.Infinity);

      console.log(fullMinY);

      graphDiv.on('plotly_selected', function(eventData) {
          var data = eventData.points,
              x = data.map(function(d) { return d.x; }),
              y = data.map(function(d) { return d.y; }),
              fn = function(Q, params) {
                  var I0 = params[0],
                      RG = params[1],
                      inside = -1.0 * Math.pow(Q, 2.0) * Math.pow(RG, 2.0) / 3.0;
                  
                  return I0 * Math.exp(inside);
              },
              tangled = x.map(function(d, i) { return [d, y[i]]; }),
              start = [1.0, 1.0],
              min = [-1000.0, -1000.0],
              max = [1000.0, 1000.0],
              fitResults = cobyla.nlFit(tangled, fn, start, min, max),
              newy = fullX.map(function(Q) {
                  var y = fn(Q, fitResults.params);
                  if (y < fullMinY) {
                      y = fullMinY;
                  }
                  return y;
              });
          
          console.log("RG =", fitResults.params[1]);

          if (trace !== null) {
              Plotly.deleteTraces(graphDiv, -1);
          }
          
          trace = { x: fullX, y: newy, type: 'scatter' };
          
          Plotly.addTraces(graphDiv, trace);
      });

      
  })();
  
</script>
{% endblock %}
